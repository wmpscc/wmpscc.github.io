<!DOCTYPE html>
<html lang="zh-CN">

  
<head>
  <meta charset="utf-8">
  <meta name="baidu-site-verification" content="5CxA73ejrD">
  <meta name="author" content="è‘£æ²…é‘«, yuanxin.me@gmail.com">
  
  
  
  <title>SKlearnå­¦ä¹ ç¬”è®° | é¸¢å°¾èŠ±å¼€</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="æ•°æ®ç§‘å­¦,sklearn,">
  

  <script>
    console.log('\n%c Hexo-theme-bmw v4.0 ' + '%c ğŸ‰ https://github.com/dongyuanxin/theme-bmw ğŸ‰\n' + '\n%c View demo online ' + '%c ğŸ” https://ishero.net/ ğŸ”  \n' , 'color: #fadfa3; background: #030307; padding:3px 0;', '', 'color: #fadfa3; background: #030307; padding:3px 0;', '');
  </script>

  
    <meta name="description" content="CV&amp;MLæŠ€æœ¯æ–°äººçš„åšå®¢ï¼Œè®°å½•æˆ‘çš„å­¦ä¹ æˆé•¿è¿‡ç¨‹ï¼">
  

  

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.css" rel="stylesheet">
  
<link rel="stylesheet" href="/css/base.css">
<link rel="stylesheet" href="/icon/iconfont.css">
<link rel="stylesheet" href="/css/github-markdown.css">
<link rel="stylesheet" href="/css/highlight.css">


  
<script src="/js/util.js"></script>
<script src="/js/valine.min.js"></script>


  
    
<link rel="stylesheet" href="/custom/style.css">

  

  

  
    <link href="https://cdn.bootcss.com/social-share.js/1.0.16/css/share.min.css" rel="stylesheet">
  
  
  <script src="//cdn.bootcss.com/jquery/3.3.1/jquery.min.js" async></script>
  
  
    <script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.0/dist/av-min.js"></script>
  

<meta name="generator" content="Hexo 4.2.0"></head>


  <body>
    <meta name="referrer" content="no-referrer">

    

    <div id="app">

      <div class="header-wrap">
  <header>
    <div class="site-brand">
      <div class="site-title">
        <a href="/">isHero.net</a>
      </div>
    </div>
    <nav class="site-navigation">
      <ul class="nav-menu">
      
        <li class="nav-item" data-path="/">
          
            <a href="/" target="_self">
              ä¸»é¡µ
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/archives/">
          
            <a href="/archives/" target="_self">
              å½’æ¡£
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/categories/">
          
            <a href="/categories/" target="_self">
              åˆ†ç±»
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/tags/">
          
            <a href="/tags/" target="_self">
              æ ‡ç­¾
            </a>
          
        </li>
      
        <li class="nav-item" data-path="/friends/">
          
            <a href="/friends/" target="_self">
              å‹é“¾
            </a>
          
        </li>
      
        <li class="nav-item" data-path="">
          
            <a href="javascript:void(0);" v-else="">å¯»æˆ‘</a>
            <ul class="nav-menu--dropdown">
              
                <li>
                  <a href="https://github.com/wmpscc" target="_blank" rel="external nofollow noopener noreferrer">
                    Github
                  </a>
                </li>
              
                <li>
                  <a href="https://www.jianshu.com/u/fde2534da842" target="_blank" rel="external nofollow noopener noreferrer">
                    ç®€ä¹¦
                  </a>
                </li>
              
                <li>
                  <a href="https://toutiao.io/subjects/345107" target="_blank" rel="external nofollow noopener noreferrer">
                    å¼€å‘è€…å¤´æ¡
                  </a>
                </li>
              
            </ul>
          
        </li>
      
      </ul>
    </nav>
    <i class="iconfont icon-menu"></i>
  </header>
</div>

<script>
  let links = document.querySelectorAll('.nav-item');
  for(let link of links){
    let childrenLink = link.querySelector('ul');
    link.addEventListener('mouseenter', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown active";
      }
    })
    link.addEventListener('mouseleave', () => {
      if(childrenLink) {
        childrenLink.className = "nav-menu--dropdown";
      }
    })
  }
  let rootRealPath = getRealPath(window.location.pathname, true);
  for(let link of links) {
    let linkPath = link.getAttribute("data-path");
    if(linkPath && getRealPath(linkPath, true) === rootRealPath) {
      link.className = "nav-item hover";
    }
  }

  let iconMenu = document.querySelector("i.iconfont.icon-menu"),
    iconMenuClicked = false;
  let navDOM = document.querySelector("nav.site-navigation");
  iconMenu.addEventListener("click", () => {
    iconMenuClicked 
      ? navDOM.className = "site-navigation active"
      : navDOM.className = "site-navigation";
    iconMenuClicked = !iconMenuClicked;
  })
</script>

      








<div class="container post-index">

  

<div class="post">
  <h1 class="article-title">
    <span>SKlearnå­¦ä¹ ç¬”è®°</span>
  </h1>
  <meta name="referrer" content="no-referrer">
  <div class="article-top-meta">
    <span>
      å‘å¸ƒ : 
      2020-01-23
    </span>
    
      <span>
        åˆ†ç±» : 
          <a href="/categories/%E6%95%B0%E6%8D%AE%E7%A7%91%E5%AD%A6/">
            æ•°æ®ç§‘å­¦
          </a>
      </span>
    
    
      <span>
        æµè§ˆ : <span class="article-timer" data-identity="SKlearnå­¦ä¹ ç¬”è®°.html"></span>
      </span>
    
  </div>

  

  <div class="article-content">
    <div class="markdown-body">
      <p>æœ¬æ–‡ä¸ºæˆ‘åœ¨å­¦ä¹ ä¸­è®°å½•çš„å‡½æ•°ï¼Œå¹¶åŠ ä»¥æ‹“å±•ã€‚</p>
<h2 id="SKlearn-æ–¹æ³•"><a href="#SKlearn-æ–¹æ³•" class="headerlink" title="SKlearn æ–¹æ³•"></a>SKlearn æ–¹æ³•</h2><h3 id="train-test-split-å°†æ•°ç»„æˆ–çŸ©é˜µåˆ†è§£ä¸ºéšæœºåºåˆ—çš„è®­ç»ƒå’Œæµ‹è¯•å­é›†-1"><a href="#train-test-split-å°†æ•°ç»„æˆ–çŸ©é˜µåˆ†è§£ä¸ºéšæœºåºåˆ—çš„è®­ç»ƒå’Œæµ‹è¯•å­é›†-1" class="headerlink" title="train_test_split() å°†æ•°ç»„æˆ–çŸ©é˜µåˆ†è§£ä¸ºéšæœºåºåˆ—çš„è®­ç»ƒå’Œæµ‹è¯•å­é›†"></a>train_test_split() å°†æ•°ç»„æˆ–çŸ©é˜µåˆ†è§£ä¸ºéšæœºåºåˆ—çš„è®­ç»ƒå’Œæµ‹è¯•å­é›†</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.model_selection import train_test_split</span><br><span class="line"></span><br><span class="line">train_set, test_set &#x3D; train_test_split(housing, test_size&#x3D;0.2, random_state&#x3D;42)</span><br></pre></td></tr></table></figure>

<ul>
<li>random_state å‚æ•°ç›¸å½“äºè®¾ç½®éšæœºæ•°ç§å­</li>
<li>stratify å¦‚æœä¸æ˜¯â€œnullâ€ï¼Œåˆ™å°†æ•°æ®ä»¥åˆ†å±‚æ–¹å¼æ‹†åˆ†ï¼Œå°†å…¶ç”¨ä½œç±»æ ‡ç­¾ã€‚</li>
</ul>
<h3 id="StratifiedShuffleSplit-å°†æ•°æ®åˆ†ä¸ºå¤šå¯¹-train-test-é›†å¹¶éšæœºæ‰“ä¹±-1"><a href="#StratifiedShuffleSplit-å°†æ•°æ®åˆ†ä¸ºå¤šå¯¹-train-test-é›†å¹¶éšæœºæ‰“ä¹±-1" class="headerlink" title="StratifiedShuffleSplit() å°†æ•°æ®åˆ†ä¸ºå¤šå¯¹ train/test é›†å¹¶éšæœºæ‰“ä¹±"></a>StratifiedShuffleSplit() å°†æ•°æ®åˆ†ä¸ºå¤šå¯¹ train/test é›†å¹¶éšæœºæ‰“ä¹±</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from  sklearn.model_selection import StratifiedShuffleSplit</span><br><span class="line">StratifiedShuffleSplit(n_splits&#x3D;10,test_size&#x3D;None,train_size&#x3D;None, random_state&#x3D;None)</span><br></pre></td></tr></table></figure>

<ul>
<li>n_splits æ˜¯å°†è®­ç»ƒæ•°æ®åˆ†æˆ train/test å¯¹çš„ç»„æ•°ï¼Œå¯æ ¹æ®éœ€è¦è¿›è¡Œè®¾ç½®ï¼Œé»˜è®¤ä¸º 10</li>
<li>å‚æ•° test_size å’Œ train_size æ˜¯ç”¨æ¥è®¾ç½® train/test å¯¹ä¸­ train å’Œ test æ‰€å çš„æ¯”ä¾‹</li>
<li>å‚æ•° random_state ç›¸å½“äºéšæœºæ•°ç§å­</li>
</ul>
<h3 id="CategoricalEncoder-ç±»-å°†-array-ä½¿ç”¨-onehot-æˆ–-ordinal-ç¼–ç "><a href="#CategoricalEncoder-ç±»-å°†-array-ä½¿ç”¨-onehot-æˆ–-ordinal-ç¼–ç " class="headerlink" title="CategoricalEncoder ç±» å°† array ä½¿ç”¨ onehot æˆ– ordinal ç¼–ç "></a>CategoricalEncoder ç±» å°† array ä½¿ç”¨ onehot æˆ– ordinal ç¼–ç </h3><p>è¿”å›ä¸€ä¸ª sparse arrayï¼Œå¯ä»¥ä½¿ç”¨<code>toarray()</code>è½¬æ¢ä¸º dense arrayï¼Œæˆ–è€…æŒ‡å®šç¼–ç ç±»å‹ä¸º<code>onehot-dense</code>æ¥å¾—åˆ° dense matrixã€‚</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.preprocessing import CategoricalEncoder</span><br><span class="line"></span><br><span class="line">cat_encoder &#x3D; CategoricalEncoder()</span><br><span class="line">housing_cat_reshaped &#x3D; housing_cat.values.reshape(-1, 1)</span><br><span class="line">housing_cat_1hot &#x3D; cat_encoder.fit_transform(housing_cat_reshaped)</span><br><span class="line">housing_cat_1hot</span><br></pre></td></tr></table></figure>

<ul>
<li>encoding : str, â€˜onehotâ€™, â€˜onehot-denseâ€™ or â€˜ordinalâ€™ï¼ŒæŒ‡å®šç¼–ç ç±»å‹ï¼Œé»˜è®¤ä¸º onehotã€‚</li>
<li>categories : â€˜autoâ€™ or a list of lists/arrays of values.</li>
<li>dtype : number type, default np.float64</li>
<li>handle_unknown : â€˜errorâ€™ (default) or â€˜ignoreâ€™</li>
</ul>
<h3 id="MinMaxScaler-MinMax-scaling-å½’ä¸€åŒ–"><a href="#MinMaxScaler-MinMax-scaling-å½’ä¸€åŒ–" class="headerlink" title="MinMaxScaler() MinMax scaling å½’ä¸€åŒ–"></a>MinMaxScaler() MinMax scaling å½’ä¸€åŒ–</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.preprocessing import MinMaxScaler</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; data &#x3D; [[-1, 2], [-0.5, 6], [0, 10], [1, 18]]</span><br><span class="line">&gt;&gt;&gt; scaler &#x3D; MinMaxScaler()</span><br><span class="line">&gt;&gt;&gt; print(scaler.fit(data))</span><br><span class="line">MinMaxScaler(copy&#x3D;True, feature_range&#x3D;(0, 1))</span><br><span class="line">&gt;&gt;&gt; print(scaler.data_max_)</span><br><span class="line">[  1.  18.]</span><br><span class="line">&gt;&gt;&gt; print(scaler.transform(data))</span><br><span class="line">[[ 0.    0.  ]</span><br><span class="line"> [ 0.25  0.25]</span><br><span class="line"> [ 0.5   0.5 ]</span><br><span class="line"> [ 1.    1.  ]]</span><br><span class="line">&gt;&gt;&gt; print(scaler.transform([[2, 2]]))</span><br><span class="line">[[ 1.5  0. ]]</span><br></pre></td></tr></table></figure>

<ul>
<li>feature_range : tuple (min, max), default=(0, 1)ï¼Œå½’ä¸€åŒ–åå€¼çš„èŒƒå›´</li>
<li>copy : boolean, optional, default Trueï¼Œæ˜¯å¦å¤åˆ¶æ•°æ®åœ¨æ–°çš„æ•°æ®ä¸Šå½’ä¸€åŒ–</li>
</ul>
<h3 id="StandardScaler-0-å‡å€¼æ ‡å‡†åŒ–"><a href="#StandardScaler-0-å‡å€¼æ ‡å‡†åŒ–" class="headerlink" title="StandardScaler() 0 å‡å€¼æ ‡å‡†åŒ–"></a>StandardScaler() 0 å‡å€¼æ ‡å‡†åŒ–</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; from sklearn.preprocessing import StandardScaler</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; data &#x3D; [[0, 0], [0, 0], [1, 1], [1, 1]]</span><br><span class="line">&gt;&gt;&gt; scaler &#x3D; StandardScaler()</span><br><span class="line">&gt;&gt;&gt; print(scaler.fit(data))</span><br><span class="line">StandardScaler(copy&#x3D;True, with_mean&#x3D;True, with_std&#x3D;True)</span><br><span class="line">&gt;&gt;&gt; print(scaler.mean_)</span><br><span class="line">[ 0.5  0.5]</span><br><span class="line">&gt;&gt;&gt; print(scaler.transform(data))</span><br><span class="line">[[-1. -1.]</span><br><span class="line"> [-1. -1.]</span><br><span class="line"> [ 1.  1.]</span><br><span class="line"> [ 1.  1.]]</span><br><span class="line">&gt;&gt;&gt; print(scaler.transform([[2, 2]]))</span><br><span class="line">[[ 3.  3.]]</span><br></pre></td></tr></table></figure>

<ul>
<li>copy : boolean, optional, default Trueï¼Œæ˜¯å¦å¤åˆ¶æ•°æ®åœ¨æ–°çš„æ•°æ®ä¸Šæ‰§è¡Œ</li>
<li>with_mean : boolean, True by defaultï¼Œè‹¥ä¸º True åˆ™åœ¨ç¼©æ”¾å‰å°†æ•°æ®å±…ä¸­ã€‚ä½†åœ¨ç¨€ç–çŸ©é˜µä¸Šæ˜¯è¡Œä¸é€šçš„ã€‚</li>
<li>with_std : boolean, True by defaultï¼Œè‹¥ä¸º Trueï¼Œåˆ™å°†æ•°æ®æ”¾ç¼©åˆ°å•ä½æ–¹å·®æˆ–ç­‰æ•ˆäºå•ä½æ ‡å‡†å·®</li>
</ul>
<h3 id="mean-squared-error-å‡æ–¹è¯¯å·®ï¼ˆMSE-and-to-RMSEï¼‰"><a href="#mean-squared-error-å‡æ–¹è¯¯å·®ï¼ˆMSE-and-to-RMSEï¼‰" class="headerlink" title="mean_squared_error() å‡æ–¹è¯¯å·®ï¼ˆMSE and to RMSEï¼‰"></a>mean_squared_error() å‡æ–¹è¯¯å·®ï¼ˆMSE and to RMSEï¼‰</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import mean_squared_error</span><br><span class="line"></span><br><span class="line">housing_predictions &#x3D; lin_reg.predict(housing_prepared)</span><br><span class="line">lin_mse &#x3D; mean_squared_error(housing_labels, housing_predictions)</span><br><span class="line">lin_rmse &#x3D; np.sqrt(lin_mse)</span><br><span class="line">lin_rmse</span><br></pre></td></tr></table></figure>

<ul>
<li>y_true : array-like of shape = (n_samples) or (n_samples, n_outputs) çœŸå®å€¼</li>
<li>y_pred : array-like of shape = (n_samples) or (n_samples, n_outputs) é¢„æµ‹å€¼</li>
</ul>
<p>è¿”å›ï¼š loss : float or ndarray of floats</p>
<h3 id="mean-absolute-error-å¹³å‡ç»å¯¹è¯¯å·®ï¼ˆMAEï¼‰"><a href="#mean-absolute-error-å¹³å‡ç»å¯¹è¯¯å·®ï¼ˆMAEï¼‰" class="headerlink" title="mean_absolute_error() å¹³å‡ç»å¯¹è¯¯å·®ï¼ˆMAEï¼‰"></a>mean_absolute_error() å¹³å‡ç»å¯¹è¯¯å·®ï¼ˆMAEï¼‰</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import mean_absolute_error</span><br><span class="line"></span><br><span class="line">lin_mae &#x3D; mean_absolute_error(housing_labels, housing_predictions)</span><br><span class="line">lin_mae</span><br></pre></td></tr></table></figure>

<ul>
<li>y_true : array-like of shape = (n_samples) or (n_samples, n_outputs) çœŸå®å€¼</li>
<li>y_pred : array-like of shape = (n_samples) or (n_samples, n_outputs) é¢„æµ‹å€¼</li>
</ul>
<p>è¿”å›ï¼šloss : float or ndarray of floats</p>
<h3 id="LinearRegression-çº¿æ€§å›å½’æ¨¡å‹"><a href="#LinearRegression-çº¿æ€§å›å½’æ¨¡å‹" class="headerlink" title="LinearRegression() çº¿æ€§å›å½’æ¨¡å‹"></a>LinearRegression() çº¿æ€§å›å½’æ¨¡å‹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.linear_model import LinearRegression</span><br><span class="line"></span><br><span class="line">lin_reg &#x3D; LinearRegression()</span><br><span class="line">lin_reg.fit(housing_prepared, housing_labels)</span><br><span class="line"># Out:LinearRegression(copy_X&#x3D;True, fit_intercept&#x3D;True, n_jobs&#x3D;1, normalize&#x3D;False)</span><br><span class="line"></span><br><span class="line"># let&#39;s try the full pipeline on a few training instances</span><br><span class="line">some_data &#x3D; housing.iloc[:5]</span><br><span class="line">some_labels &#x3D; housing_labels.iloc[:5]</span><br><span class="line">some_data_prepared &#x3D; full_pipeline.transform(some_data)</span><br><span class="line"></span><br><span class="line">print(&quot;Predictions:&quot;, lin_reg.predict(some_data_prepared))</span><br><span class="line"># Out:Predictions: [ 210644.60459286  317768.80697211  210956.43331178   59218.98886849  189747.55849879]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Methods</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>fit(X, y[, sample_weight])</td>
<td>Fit linear model.</td>
</tr>
<tr>
<td>get_params([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr>
<td>predict(X)</td>
<td>Predict using the linear model</td>
</tr>
<tr>
<td>score(X, y[, sample_weight])</td>
<td>Returns the coefficient of determination R^2 of the prediction.</td>
</tr>
<tr>
<td>set_params(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
</tbody></table>
<h3 id="DecisionTreeRegressor-å†³ç­–æ ‘æ¨¡å‹"><a href="#DecisionTreeRegressor-å†³ç­–æ ‘æ¨¡å‹" class="headerlink" title="DecisionTreeRegressor() å†³ç­–æ ‘æ¨¡å‹"></a>DecisionTreeRegressor() å†³ç­–æ ‘æ¨¡å‹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.tree import DecisionTreeRegressor</span><br><span class="line"></span><br><span class="line">tree_reg &#x3D; DecisionTreeRegressor(random_state&#x3D;42)</span><br><span class="line">tree_reg.fit(housing_prepared, housing_labels)</span><br><span class="line"># Out:</span><br><span class="line"># DecisionTreeRegressor(criterion&#x3D;&#39;mse&#39;, max_depth&#x3D;None, max_features&#x3D;None,</span><br><span class="line">#            max_leaf_nodes&#x3D;None, min_impurity_decrease&#x3D;0.0,</span><br><span class="line">#            min_impurity_split&#x3D;None, min_samples_leaf&#x3D;1,</span><br><span class="line">#            min_samples_split&#x3D;2, min_weight_fraction_leaf&#x3D;0.0,</span><br><span class="line">#            presort&#x3D;False, random_state&#x3D;42, splitter&#x3D;&#39;best&#39;)</span><br><span class="line"></span><br><span class="line">housing_predictions &#x3D; tree_reg.predict(housing_prepared)</span><br><span class="line"># è®¡ç®—RMSE</span><br><span class="line">tree_mse &#x3D; mean_squared_error(housing_labels, housing_predictions)</span><br><span class="line">tree_rmse &#x3D; np.sqrt(tree_mse)</span><br><span class="line">tree_rmse</span><br><span class="line"># Out: 0.0</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Methods</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>apply(X[, check_input])</td>
<td>Returns the index of the leaf that each sample is predicted as.</td>
</tr>
<tr>
<td>decision_path(X[, check_input])</td>
<td>Return the decision path in the tree</td>
</tr>
<tr>
<td>fit(X, y[, sample_weight, check_input, â€¦])</td>
<td>Build a decision tree regressor from the training set (X, y).</td>
</tr>
<tr>
<td>get_params([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr>
<td>predict(X[, check_input])</td>
<td>Predict class or regression value for X.</td>
</tr>
<tr>
<td>score(X, y[, sample_weight])</td>
<td>Returns the coefficient of determination R^2 of the prediction.</td>
</tr>
<tr>
<td>set_params(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
</tbody></table>
<h3 id="RandomForestRegressor-éšæœºæ£®æ—å›å½’"><a href="#RandomForestRegressor-éšæœºæ£®æ—å›å½’" class="headerlink" title="RandomForestRegressor() éšæœºæ£®æ—å›å½’"></a>RandomForestRegressor() éšæœºæ£®æ—å›å½’</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.ensemble import RandomForestRegressor</span><br><span class="line"></span><br><span class="line">forest_reg &#x3D; RandomForestRegressor(random_state&#x3D;42)</span><br><span class="line">forest_reg.fit(housing_prepared, housing_labels)</span><br><span class="line"></span><br><span class="line">housing_predictions &#x3D; forest_reg.predict(housing_prepared)</span><br><span class="line">forest_mse &#x3D; mean_squared_error(housing_labels, housing_predictions)</span><br><span class="line">forest_rmse &#x3D; np.sqrt(forest_mse)</span><br><span class="line">forest_rmse</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>Methods</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>apply(X)</td>
<td>Apply trees in the forest to X, return leaf indices.</td>
</tr>
<tr>
<td>decision_path(X)</td>
<td>Return the decision path in the forest</td>
</tr>
<tr>
<td>fit(X, y[, sample_weight])</td>
<td>Build a forest of trees from the training set (X, y).</td>
</tr>
<tr>
<td>get_params([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr>
<td>predict(X)</td>
<td>Predict regression target for X.</td>
</tr>
<tr>
<td>score(X, y[, sample_weight])</td>
<td>Returns the coefficient of determination R^2 of the prediction.</td>
</tr>
<tr>
<td>set_params(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
</tbody></table>
<h3 id="cross-val-score-K-fold-äº¤å‰éªŒè¯"><a href="#cross-val-score-K-fold-äº¤å‰éªŒè¯" class="headerlink" title="cross_val_score() K-fold äº¤å‰éªŒè¯"></a>cross_val_score() K-fold äº¤å‰éªŒè¯</h3><p>å®ƒçš„æœŸæœ›æ˜¯ä¸€ä¸ªæ•ˆç”¨å‡½æ•°è¶Šå¤§è¶Šå¥½ï¼Œæ‰€ä»¥å®ƒçš„è¯„åˆ†å‡½æ•°æ˜¯ä¸€ä¸ª<code>è´Ÿå€¼</code>ã€‚è¿™å°±æ˜¯ä¸ºä»€ä¹ˆåœ¨è®¡ç®—å¼€å¹³æ–¹æ—¶å–ç›¸åæ•°ï¼ˆ-scoresï¼‰</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.model_selection import cross_val_score</span><br><span class="line"></span><br><span class="line">scores &#x3D; cross_val_score(tree_reg, housing_prepared, housing_labels,</span><br><span class="line">                         scoring&#x3D;&quot;neg_mean_squared_error&quot;, cv&#x3D;10)</span><br><span class="line">tree_rmse_scores &#x3D; np.sqrt(-scores)</span><br></pre></td></tr></table></figure>

<ul>
<li>estimator : estimator object implementing â€˜fitâ€™ ç”¨äºæ‹Ÿåˆæ•°æ®çš„å¯¹è±¡ï¼Œæ­¤å¤„ä½¿ç”¨çš„æ˜¯å†³ç­–æ ‘ tree_regã€‚</li>
<li>X : array-like è¦æ‹Ÿåˆçš„æ•°æ®ï¼Œå¯ä»¥æ˜¯ list æˆ– arrayã€‚</li>
<li>y : array-like, optional, default: None ç›‘ç£å­¦ä¹ ä¸‹å°è¯•é¢„æµ‹çš„ç›®æ ‡å€¼</li>
<li>scoring : string, callable or None, optional, default: None ä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œå‚è§æ¨¡å‹è¯„ä¼°æ–‡æ¡£ã€‚</li>
<li>cv : int, cross-validation generator or an iterable, optionalï¼Œå†³å®šäº¤å‰éªŒè¯æ‹†åˆ†ç­–ç•¥ï¼ŒK-fold</li>
</ul>
<h3 id="joblib-ä¿å­˜æ¨¡å‹"><a href="#joblib-ä¿å­˜æ¨¡å‹" class="headerlink" title="joblib ä¿å­˜æ¨¡å‹"></a>joblib ä¿å­˜æ¨¡å‹</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.externals import joblib</span><br><span class="line"></span><br><span class="line">joblib.dump(my_model, &quot;my_model.pkl&quot;)</span><br><span class="line"># and later...</span><br><span class="line">my_model_loaded &#x3D; joblib.load(&quot;my_model.pkl&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="SVR-Îµ-SVM-å›å½’"><a href="#SVR-Îµ-SVM-å›å½’" class="headerlink" title="SVR() Îµ-SVM å›å½’"></a>SVR() Îµ-SVM å›å½’</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.svm import SVR</span><br><span class="line"></span><br><span class="line">svm_reg &#x3D; SVR(kernel&#x3D;&quot;linear&quot;)</span><br><span class="line">svm_reg.fit(housing_prepared, housing_labels)</span><br><span class="line">housing_predictions &#x3D; svm_reg.predict(housing_prepared)</span><br><span class="line">svm_mse &#x3D; mean_squared_error(housing_labels, housing_predictions)</span><br><span class="line">svm_rmse &#x3D; np.sqrt(svm_mse)</span><br><span class="line">svm_rmse</span><br></pre></td></tr></table></figure>

<ul>
<li>C : float, optional (default=1.0)ï¼Œè¯¯å·®é¡¹æƒ©ç½šå‚æ•°</li>
<li>kernel : string, optional (default=â€™rbfâ€™)ï¼Œ å¿…é¡»æ˜¯â€˜linearâ€™, â€˜polyâ€™, â€˜rbfâ€™, â€˜sigmoidâ€™, â€˜precomputedâ€™ æˆ–è€…æä¾›ä¸€ä¸ªå‡½æ•°ï¼Œå¦‚æœæ˜¯æä¾›äº†å‡½æ•°åˆ™å°†å®ƒç”¨æ¥é¢„å…ˆè®¡ç®—æ ¸å¿ƒçŸ©é˜µã€‚<table>
<thead>
<tr>
<th>Methods</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>fit(X, y[, sample_weight])</td>
<td>Fit the SVM model according to the given training data.</td>
</tr>
<tr>
<td>get_params([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr>
<td>predict(X)</td>
<td>Perform regression on samples in X.</td>
</tr>
<tr>
<td>score(X, y[, sample_weight])</td>
<td>Returns the coefficient of determination R^2 of the prediction.</td>
</tr>
<tr>
<td>set_params(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="GridSearchCV-å¯¹ä¼°ç®—å™¨æŒ‡å®šå‚æ•°å€¼è¿›è¡Œè¯¦å°½æœç´¢"><a href="#GridSearchCV-å¯¹ä¼°ç®—å™¨æŒ‡å®šå‚æ•°å€¼è¿›è¡Œè¯¦å°½æœç´¢" class="headerlink" title="GridSearchCV() å¯¹ä¼°ç®—å™¨æŒ‡å®šå‚æ•°å€¼è¿›è¡Œè¯¦å°½æœç´¢"></a>GridSearchCV() å¯¹ä¼°ç®—å™¨æŒ‡å®šå‚æ•°å€¼è¿›è¡Œè¯¦å°½æœç´¢</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.model_selection import GridSearchCV</span><br><span class="line"></span><br><span class="line">param_grid &#x3D; [</span><br><span class="line">    # try 12 (3Ã—4) combinations of hyperparameters</span><br><span class="line">    &#123;&#39;n_estimators&#39;: [3, 10, 30], &#39;max_features&#39;: [2, 4, 6, 8]&#125;,</span><br><span class="line">    # then try 6 (2Ã—3) combinations with bootstrap set as False</span><br><span class="line">    &#123;&#39;bootstrap&#39;: [False], &#39;n_estimators&#39;: [3, 10], &#39;max_features&#39;: [2, 3, 4]&#125;,</span><br><span class="line">  ]</span><br><span class="line"></span><br><span class="line">forest_reg &#x3D; RandomForestRegressor(random_state&#x3D;42)</span><br><span class="line"># train across 5 folds, that&#39;s a total of (12+6)*5&#x3D;90 rounds of training</span><br><span class="line">grid_search &#x3D; GridSearchCV(forest_reg, param_grid, cv&#x3D;5,</span><br><span class="line">                           scoring&#x3D;&#39;neg_mean_squared_error&#39;)</span><br><span class="line">grid_search.fit(housing_prepared, housing_labels)</span><br><span class="line"></span><br><span class="line">grid_search.best_params_</span><br><span class="line"># Out:&#123;&#39;max_features&#39;: 8, &#39;n_estimators&#39;: 30&#125;</span><br><span class="line"></span><br><span class="line">grid_search.best_estimator_</span><br><span class="line"># Out:</span><br><span class="line"># RandomForestRegressor(bootstrap&#x3D;True, criterion&#x3D;&#39;mse&#39;, max_depth&#x3D;None,</span><br><span class="line">#            max_features&#x3D;8, max_leaf_nodes&#x3D;None, min_impurity_decrease&#x3D;0.0,</span><br><span class="line">#            min_impurity_split&#x3D;None, min_samples_leaf&#x3D;1,</span><br><span class="line">#            min_samples_split&#x3D;2, min_weight_fraction_leaf&#x3D;0.0,</span><br><span class="line">#            n_estimators&#x3D;30, n_jobs&#x3D;1, oob_score&#x3D;False, random_state&#x3D;42,</span><br><span class="line">#            verbose&#x3D;0, warm_start&#x3D;False)</span><br></pre></td></tr></table></figure>

<ul>
<li>estimator : estimator object.æ¯ä¸ªä¼°ç®—å™¨éœ€è¦æä¾›ä¸€ä¸ª<code>score</code>å‡½æ•°æˆ–å¡«å†™<code>scoring</code>å‚æ•°ã€‚</li>
<li>param_grid : dict or list of dictionariesï¼Œé”®ä½œä¸ºå‚æ•°åç§°ï¼Œlist ä½œä¸ºå‚æ•°çš„å­—å…¸ã€‚æˆ–å­˜æœ‰è¿™æ ·çš„å­—å…¸çš„åˆ—è¡¨ã€‚</li>
<li>scoring : string, callable, list/tuple, dict or None, default: Noneï¼Œ</li>
<li>cv : int, cross-validation generator or an iterable, optionalï¼Œå¦‚æœæ˜¯æ•´æ•°ï¼Œåˆ™ä»£è¡¨ KFold</li>
<li>refit : boolean, or string, default=Trueï¼Œåº”ç”¨å·²æ‰¾åˆ°çš„æœ€å¥½çš„å‚æ•°åˆ°æ•´ä¸ªæ•°æ®é›†ä¸Šã€‚<table>
<thead>
<tr>
<th>Methods</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>decision_function(X)</td>
<td>Call decision_function on the estimator with the best found parameters.</td>
</tr>
<tr>
<td>fit(X[, y, groups])</td>
<td>Run fit with all sets of parameters.</td>
</tr>
<tr>
<td>get_params([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr>
<td>inverse_transform(Xt)</td>
<td>Call inverse_transform on the estimator with the best found params.</td>
</tr>
<tr>
<td>predict(X)</td>
<td>Call predict on the estimator with the best found parameters.</td>
</tr>
<tr>
<td>predict_log_proba(X)</td>
<td>Call predict_log_proba on the estimator with the best found parameters.</td>
</tr>
<tr>
<td>predict_proba(X)</td>
<td>Call predict_proba on the estimator with the best found parameters.</td>
</tr>
<tr>
<td>score(X[, y])</td>
<td>Returns the score on the given data, if the estimator has been refit.</td>
</tr>
<tr>
<td>set_params(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
<tr>
<td>transform(X)</td>
<td>Call transform on the estimator with the best found parameters.</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="RandomizedSearchCV"><a href="#RandomizedSearchCV" class="headerlink" title="RandomizedSearchCV()"></a>RandomizedSearchCV()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.model_selection import RandomizedSearchCV</span><br><span class="line">from scipy.stats import randint</span><br><span class="line"></span><br><span class="line">param_distribs &#x3D; &#123;</span><br><span class="line">        &#39;n_estimators&#39;: randint(low&#x3D;1, high&#x3D;200),</span><br><span class="line">        &#39;max_features&#39;: randint(low&#x3D;1, high&#x3D;8),</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">forest_reg &#x3D; RandomForestRegressor(random_state&#x3D;42)</span><br><span class="line">rnd_search &#x3D; RandomizedSearchCV(forest_reg, param_distributions&#x3D;param_distribs,</span><br><span class="line">                                n_iter&#x3D;10, cv&#x3D;5, scoring&#x3D;&#39;neg_mean_squared_error&#39;, random_state&#x3D;42)</span><br><span class="line">rnd_search.fit(housing_prepared, housing_labels)</span><br></pre></td></tr></table></figure>

<ul>
<li>estimator : estimator object.æŒ‡å®šä¼°ç®—å™¨å¯¹è±¡ã€‚</li>
<li>param_distributions : dictï¼Œç»™å®šä»¥å‚æ•°åä¸ºé”®ï¼Œlist ä¸ºå‚æ•°çš„å­—å…¸ã€‚æˆ–æä¾›ä¸€ä¸ªåˆ†å¸ƒï¼Œåˆ†å¸ƒå¿…é¡»æä¾›ä¸€ä¸ª<code>rvs</code>æ–¹æ³•è¿›è¡Œé‡‡æ ·ï¼Œä¾‹å¦‚æ¥è‡ª scipy.stats.distributions çš„æ–¹æ³•ã€‚</li>
<li>n_iter : int, default=10ï¼Œé‡‡æ ·å‚æ•°è®¾ç½®æ•°é‡ã€‚</li>
<li>scoring : string, callable, list/tuple, dict or None, default: None</li>
<li>cv : int, cross-validation generator or an iterable, optional</li>
<li>refit : boolean, or string default=True</li>
<li>random_state : int, RandomState instance or None, optional, default=None</li>
</ul>
<h3 id="Imputer-å¤„ç†ä¸¢å¤±å€¼"><a href="#Imputer-å¤„ç†ä¸¢å¤±å€¼" class="headerlink" title="Imputer() å¤„ç†ä¸¢å¤±å€¼"></a>Imputer() å¤„ç†ä¸¢å¤±å€¼</h3><p>å„å±æ€§å¿…é¡»æ˜¯æ•°å€¼</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.preprocessing import Imputer</span><br><span class="line"># æŒ‡å®šç”¨ä½•å€¼æ›¿æ¢ä¸¢å¤±çš„å€¼ï¼Œæ­¤å¤„ä¸ºä¸­ä½æ•°</span><br><span class="line">imputer &#x3D; Imputer(strategy&#x3D;&quot;median&quot;)</span><br><span class="line"></span><br><span class="line"># ä½¿å®ä¾‹é€‚åº”æ•°æ®</span><br><span class="line">imputer.fit(housing_num)</span><br><span class="line"></span><br><span class="line"># ç»“æœåœ¨statistics_ å˜é‡ä¸­</span><br><span class="line">imputer.statistics_</span><br><span class="line"></span><br><span class="line"># æ›¿æ¢</span><br><span class="line">X &#x3D; imputer.transform(housing_num)</span><br><span class="line">housing_tr &#x3D; pd.DataFrame(X, columns&#x3D;housing_num.columns,</span><br><span class="line">                          index &#x3D; list(housing.index.values))</span><br><span class="line"></span><br><span class="line"># é¢„è§ˆ</span><br><span class="line">housing_tr.loc[sample_incomplete_rows.index.values]</span><br></pre></td></tr></table></figure>

<h3 id="fetch-mldata-ä¸‹è½½å¸¸ç”¨çš„æ•°æ®é›†"><a href="#fetch-mldata-ä¸‹è½½å¸¸ç”¨çš„æ•°æ®é›†" class="headerlink" title="fetch_mldata() ä¸‹è½½å¸¸ç”¨çš„æ•°æ®é›†"></a>fetch_mldata() ä¸‹è½½å¸¸ç”¨çš„æ•°æ®é›†</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># ä¾‹å¦‚ä¸‹è½½MNISTæ•°æ®é›†</span><br><span class="line">from sklearn.datasets import fetch_mldata</span><br><span class="line">mnist &#x3D; fetch_mldata(&#39;MNIST original&#39;)</span><br></pre></td></tr></table></figure>

<ul>
<li>dataname : strï¼›mldata.org ä¸Šçš„æ•°æ®é›†çš„åç§°ï¼ŒåŸå§‹åç§°ä¼šè‡ªåŠ¨è½¬æ¢ä¸º mldata.org ç½‘å€ã€‚</li>
</ul>
<h3 id="cross-val-predict-äº¤å‰é¢„æµ‹"><a href="#cross-val-predict-äº¤å‰é¢„æµ‹" class="headerlink" title="cross_val_predict() äº¤å‰é¢„æµ‹"></a>cross_val_predict() äº¤å‰é¢„æµ‹</h3><p>ä¸ºæ¯ä¸ªè¾“å…¥æ•°æ®ç‚¹ç”Ÿæˆäº¤å‰éªŒè¯çš„ä¼°è®¡å€¼</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.model_selection import cross_val_predict</span><br><span class="line"></span><br><span class="line">y_train_pred &#x3D; cross_val_predict(sgd_clf, X_train, y_train_5, cv&#x3D;3)</span><br></pre></td></tr></table></figure>

<ul>
<li>estimator : estimator object implementing â€˜fitâ€™ and â€˜predictâ€™</li>
<li>X : array-like</li>
<li>y : array-like, optional, default: None</li>
<li>cv : int, cross-validation generator or an iterable, optional</li>
</ul>
<p>é€šè¿‡äº¤å‰éªŒè¯å¾—åˆ° F1 åˆ†æ•°</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y_scores &#x3D; cross_val_predict(sgd_clf, X_train, y_train_5, cv&#x3D;3,</span><br><span class="line">                             method&#x3D;&quot;decision_function&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="confusion-matrix-è®¡ç®—æ··æ·†çŸ©é˜µ"><a href="#confusion-matrix-è®¡ç®—æ··æ·†çŸ©é˜µ" class="headerlink" title="confusion_matrix() è®¡ç®—æ··æ·†çŸ©é˜µ"></a>confusion_matrix() è®¡ç®—æ··æ·†çŸ©é˜µ</h3><p>è®¡ç®—æ··æ·†çŸ©é˜µæ¥è¯„ä¼°åˆ†ç±»çš„å‡†ç¡®æ€§</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import confusion_matrix</span><br><span class="line"></span><br><span class="line">confusion_matrix(y_train_5, y_train_pred)</span><br></pre></td></tr></table></figure>

<ul>
<li>y_true : array, shape = [n_samples]; æ­£ç¡®çš„ç›®æ ‡å€¼</li>
<li>y_pred : array, shape = [n_samples]ï¼› åˆ†ç±»å™¨è¿”å›çš„ç›®æ ‡ä¼°è®¡å€¼</li>
<li>labels : array, shape = [n_classes], optionalï¼›ç´¢å¼•çŸ©é˜µçš„æ ‡ç­¾åˆ—è¡¨ã€‚</li>
<li>sample_weight : array-like of shape = [n_samples], optionalï¼› æ ·å“æƒé‡</li>
</ul>
<h3 id="f1-score-è®¡ç®—-F1-åˆ†æ•°"><a href="#f1-score-è®¡ç®—-F1-åˆ†æ•°" class="headerlink" title="f1_score() è®¡ç®— F1 åˆ†æ•°"></a>f1_score() è®¡ç®— F1 åˆ†æ•°</h3><p>F1 å¯ä»¥è¢«è§£è¯»ä¸º <code>precision</code> ä¸ <code>recall</code> çš„åŠ æƒå¹³å‡æ•°ï¼Œè¦å¾—ä½¿ F1 å¾—åˆ°é«˜åˆ†ï¼Œåˆ™å¿…é¡»ä½¿ <code>precision</code> å’Œ <code>recall</code> é«˜ã€‚</p>
<ul>
<li>F1 score è®¡ç®—å…¬å¼</li>
</ul>
<p><code>F1 = 2 * (precision * recall) / (precision + recall)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import f1_score</span><br><span class="line">f1_score(y_train_5, y_train_pred)</span><br></pre></td></tr></table></figure>

<ul>
<li>y_true : 1d array-like, or label indicator array / sparse matrixï¼› çœŸå®çš„ç›®æ ‡å€¼</li>
<li>y_pred : 1d array-like, or label indicator array / sparse matrixï¼› åˆ†ç±»å™¨è¿”å›çš„ç›®æ ‡ä¼°è®¡å€¼</li>
<li>average : string, [None, â€˜binaryâ€™ (default), â€˜microâ€™, â€˜macroâ€™, â€˜samplesâ€™, â€˜weightedâ€™]; è¿™ä¸ªå‚æ•°éœ€è¦ multiclass/multilabel çš„ç›®æ ‡ã€‚å¦‚æœä¸ºç©ºï¼Œæ¯ä¸ªç±»çš„åˆ†æ•°è¢«è¿”å›ã€‚å¦åˆ™ï¼Œå°†æ‰§è¡Œä¸‹é¢çš„å¹³å‡æ“ä½œã€‚<table>
<thead>
<tr>
<th>keys</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>â€˜binaryâ€™</td>
<td>Only report results for the class specified by pos<em>label. This is applicable only if targets (y</em>{true,pred}) are binary.</td>
</tr>
<tr>
<td>â€˜microâ€™</td>
<td>Calculate metrics globally by counting the total true positives, false negatives and false positives.</td>
</tr>
<tr>
<td>â€˜macroâ€™</td>
<td>Calculate metrics for each label, and find their unweighted mean. This does not take label imbalance into account.</td>
</tr>
<tr>
<td>â€˜weightedâ€™</td>
<td>Calculate metrics for each label, and find their average, weighted by support (the number of true instances for each label). This alters â€˜macroâ€™ to account for label imbalance; it can result in an F-score that is not between precision and recall.</td>
</tr>
<tr>
<td>â€˜samplesâ€™</td>
<td>Calculate metrics for each instance, and find their average (only meaningful for multilabel classification where this differs from accuracy_score).</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="decision-function-è¿”å›æ¯ä¸ªå®ä¾‹çš„-F1-åˆ†æ•°-æ–¹ä¾¿ä½¿ç”¨é˜ˆå€¼"><a href="#decision-function-è¿”å›æ¯ä¸ªå®ä¾‹çš„-F1-åˆ†æ•°-æ–¹ä¾¿ä½¿ç”¨é˜ˆå€¼" class="headerlink" title="decision_function() è¿”å›æ¯ä¸ªå®ä¾‹çš„ F1 åˆ†æ•°(æ–¹ä¾¿ä½¿ç”¨é˜ˆå€¼)"></a>decision_function() è¿”å›æ¯ä¸ªå®ä¾‹çš„ F1 åˆ†æ•°(æ–¹ä¾¿ä½¿ç”¨é˜ˆå€¼)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">y_scores &#x3D; sgd_clf.decision_function([some_digit])</span><br><span class="line"></span><br><span class="line">threshold &#x3D; 0   # è®¾å®šé˜ˆå€¼</span><br><span class="line">y_some_digit_pred &#x3D; (y_scores &gt; threshold)</span><br><span class="line"></span><br><span class="line">threshold &#x3D; 200000    # è®¾å®šé˜ˆå€¼</span><br><span class="line">y_some_digit_pred &#x3D; (y_scores &gt; threshold)</span><br></pre></td></tr></table></figure>

<p>é€šè¿‡äº¤å‰éªŒè¯å¾—åˆ°åˆ†æ•°</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">y_scores &#x3D; cross_val_predict(sgd_clf, X_train, y_train_5, cv&#x3D;3,</span><br><span class="line">                             method&#x3D;&quot;decision_function&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="precision-recall-curve-é’ˆå¯¹ä¸åŒçš„æ¦‚ç‡é˜ˆå€¼è®¡ç®—"><a href="#precision-recall-curve-é’ˆå¯¹ä¸åŒçš„æ¦‚ç‡é˜ˆå€¼è®¡ç®—" class="headerlink" title="precision_recall_curve() é’ˆå¯¹ä¸åŒçš„æ¦‚ç‡é˜ˆå€¼è®¡ç®—"></a>precision_recall_curve() é’ˆå¯¹ä¸åŒçš„æ¦‚ç‡é˜ˆå€¼è®¡ç®—</h3><p>precision ratio <code>tp / (tp + fp)</code>; recall ratio <code>tp / (tp + fn)</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import precision_recall_curve</span><br><span class="line"></span><br><span class="line">precisions, recalls, thresholds &#x3D; precision_recall_curve(y_train_5, y_scores)</span><br></pre></td></tr></table></figure>

<h6 id="å‚æ•°"><a href="#å‚æ•°" class="headerlink" title="å‚æ•°"></a>å‚æ•°</h6><ul>
<li>y_true : array, shape = [n_samples]; åœ¨{-1, 1} or {0, 1}èŒƒå›´å†…ï¼Œç›®æ ‡çš„äºŒè¿›åˆ¶åˆ†ç±»ã€‚</li>
<li>probas_pred : array, shape = [n_samples]ï¼› ä¼°è®¡æ¦‚ç‡æˆ–å†³ç­–å‡½æ•°ã€‚</li>
</ul>
<h6 id="è¿”å›å€¼"><a href="#è¿”å›å€¼" class="headerlink" title="è¿”å›å€¼"></a>è¿”å›å€¼</h6><ul>
<li>precision : array, shape = [n_thresholds + 1]</li>
<li>recall : array, shape = [n_thresholds + 1]</li>
<li>thresholds : array, shape = [n_thresholds &lt;= len(np.unique(probas_pred))]</li>
</ul>
<h3 id="precision-score"><a href="#precision-score" class="headerlink" title="precision_score()"></a>precision_score()</h3><p>The precision is the ratio <code>tp / (tp + fp)</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">precision_score(y_train_5, y_train_pred_90)</span><br></pre></td></tr></table></figure>

<h6 id="å‚æ•°-1"><a href="#å‚æ•°-1" class="headerlink" title="å‚æ•°"></a>å‚æ•°</h6><ul>
<li><p>y_true : 1d array-like, or label indicator array / sparse matrix; æ­£ç¡®çš„ç›®æ ‡å®é™…å€¼ã€‚</p>
</li>
<li><p>y_pred : 1d array-like, or label indicator array / sparse matrix; ç”±åˆ†ç±»å™¨è¿”å›çš„ç›®æ ‡ä¼°è®¡å€¼<br>è¿”å›å€¼</p>
</li>
<li><p>precision : float (if average is not None) or array of float, shape = [n_unique_labels]</p>
</li>
</ul>
<h3 id="recall-score"><a href="#recall-score" class="headerlink" title="recall_score()"></a>recall_score()</h3><p>The recall is the ratio <code>tp / (tp + fn)</code>.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recall_score(y_train_5, y_train_pred_90)</span><br></pre></td></tr></table></figure>

<h6 id="å‚æ•°-2"><a href="#å‚æ•°-2" class="headerlink" title="å‚æ•°"></a>å‚æ•°</h6><ul>
<li>y_true : 1d array-like, or label indicator array / sparse matrix; æ­£ç¡®çš„ç›®æ ‡å®é™…å€¼</li>
<li>y_pred : 1d array-like, or label indicator array / sparse matrix; ç”±åˆ†ç±»å™¨è¿”å›çš„ç›®æ ‡ä¼°è®¡å€¼</li>
</ul>
<h6 id="è¿”å›å€¼-1"><a href="#è¿”å›å€¼-1" class="headerlink" title="è¿”å›å€¼"></a>è¿”å›å€¼</h6><ul>
<li>recall : float (if average is not None) or array of float, shape = [n_unique_labels]</li>
</ul>
<h3 id="roc-curve-è®¡ç®—-ROC"><a href="#roc-curve-è®¡ç®—-ROC" class="headerlink" title="roc_curve() è®¡ç®— ROC"></a>roc_curve() è®¡ç®— ROC</h3><p>æ³¨æ„ï¼šæ­¤å®ç°ä»…é™äºäºŒè¿›åˆ¶åˆ†ç±»ä»»åŠ¡ã€‚</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import roc_curve</span><br><span class="line"></span><br><span class="line">fpr, tpr, thresholds &#x3D; roc_curve(y_train_5, y_scores)</span><br></pre></td></tr></table></figure>

<h6 id="å‚æ•°-3"><a href="#å‚æ•°-3" class="headerlink" title="å‚æ•°"></a>å‚æ•°</h6><ul>
<li>y_true : array, shape = [n_samples]; èŒƒå›´ä¸º{0, 1}æˆ–{-1, 1}çš„çœŸå®äºŒå…ƒæ ‡ç­¾ã€‚å¦‚æœæ ‡ç­¾ä¸æ˜¯äºŒè¿›åˆ¶çš„ï¼Œåº”æ˜ç¡®ç»™å‡º pos_label å‚æ•°ã€‚</li>
<li>y_score : array, shape = [n_samples]; ç”±ä¸€äº›åˆ†ç±»å™¨çš„â€decision_functionâ€è¿”å›ï¼Œç›®æ ‡åˆ†æ•°å¯ä»¥æ˜¯<code>positive class</code>çš„æ¦‚ç‡ä¼°è®¡ã€<code>confidence values</code>æˆ–éé˜ˆå€¼åŒ–å†³ç­–çš„é‡åº¦ã€‚</li>
<li>pos_label : int or str, default=None; æ ‡ç­¾è¢«è®¤ä¸ºæ˜¯ positiveï¼Œå…¶ä»–çš„åˆ™è¢«è®¤ä¸ºæ˜¯ negativeã€‚</li>
</ul>
<h6 id="è¿”å›å€¼-2"><a href="#è¿”å›å€¼-2" class="headerlink" title="è¿”å›å€¼"></a>è¿”å›å€¼</h6><ul>
<li>fpr : array, shape = [&gt;2]</li>
<li>tpr : array, shape = [&gt;2]</li>
<li>thresholds : array, shape = [n_thresholds]</li>
</ul>
<h3 id="roc-auc-score-ä»é¢„æµ‹åˆ†æ•°è®¡ç®—-ROC-AUC"><a href="#roc-auc-score-ä»é¢„æµ‹åˆ†æ•°è®¡ç®—-ROC-AUC" class="headerlink" title="roc_auc_score() ä»é¢„æµ‹åˆ†æ•°è®¡ç®— ROC AUC"></a>roc_auc_score() ä»é¢„æµ‹åˆ†æ•°è®¡ç®— ROC AUC</h3><p>æ³¨æ„ï¼šæ­¤å®ç°ä»…é™äºäºŒè¿›åˆ¶åˆ†ç±»ä»»åŠ¡æˆ–æ ‡ç­¾æŒ‡ç¤ºç¬¦æ ¼å¼çš„å¤šæ ‡ç­¾åˆ†ç±»ä»»åŠ¡ã€‚</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import roc_auc_score</span><br><span class="line"></span><br><span class="line">roc_auc_score(y_train_5, y_scores)</span><br></pre></td></tr></table></figure>

<h6 id="å‚æ•°-4"><a href="#å‚æ•°-4" class="headerlink" title="å‚æ•°"></a>å‚æ•°</h6><ul>
<li>y_true : array, shape = [n_samples] or [n_samples, n_classes]; äºŒè¿›åˆ¶æ ‡ç­¾æŒ‡ç¤ºç¬¦ä¸­çš„çœŸå®äºŒè¿›åˆ¶æ ‡ç­¾</li>
<li>y_score : array, shape = [n_samples] or [n_samples, n_classes]; ç”±ä¸€äº›åˆ†ç±»å™¨çš„â€decision_functionâ€è¿”å›ï¼Œç›®æ ‡åˆ†æ•°å¯ä»¥æ˜¯<code>positive class</code>çš„æ¦‚ç‡ä¼°è®¡ã€<code>confidence values</code>æˆ–éé˜ˆå€¼åŒ–å†³ç­–çš„é‡åº¦ã€‚</li>
</ul>
<h6 id="è¿”å›å€¼-3"><a href="#è¿”å›å€¼-3" class="headerlink" title="è¿”å›å€¼"></a>è¿”å›å€¼</h6><ul>
<li>auc : float</li>
</ul>
<h3 id="classes-æ•°ç»„-array"><a href="#classes-æ•°ç»„-array" class="headerlink" title="~classes_   æ•°ç»„(array)"></a>~classes_   æ•°ç»„(array)</h3><p>åˆ†ç±»å™¨è®­ç»ƒçš„ç›®æ ‡åˆ†ç±»ï¼Œåˆ—è¡¨å­˜å‚¨åœ¨å®ƒçš„ classes_å±æ€§ä¸­ï¼Œé¡ºåºç”±å€¼å†³å®šã€‚ä¾‹å¦‚</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sgd_clf.classes_</span><br><span class="line"># array([ 0.,  1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9.])</span><br><span class="line"></span><br><span class="line">sgd_clf.classes_[5]</span><br><span class="line"># 5.0</span><br></pre></td></tr></table></figure>

<h3 id="å¼ºåˆ¶-SKlearn-ä½¿ç”¨-OvO-ç­–ç•¥æˆ–-OvA-ç­–ç•¥"><a href="#å¼ºåˆ¶-SKlearn-ä½¿ç”¨-OvO-ç­–ç•¥æˆ–-OvA-ç­–ç•¥" class="headerlink" title="å¼ºåˆ¶ SKlearn ä½¿ç”¨ OvO ç­–ç•¥æˆ– OvA ç­–ç•¥"></a>å¼ºåˆ¶ SKlearn ä½¿ç”¨ OvO ç­–ç•¥æˆ– OvA ç­–ç•¥</h3><p>Sklearn å¯¹äºä½¿ç”¨äºŒè¿›åˆ¶åˆ†ç±»å™¨è®­ç»ƒå‡ºå¤šé¡¹åˆ†ç±»å™¨ä¼šè‡ªåŠ¨ä½¿ç”¨ OvA ç­–ç•¥ï¼Œé™¤äº† SVM åˆ†ç±»å™¨ä½¿ç”¨ OvO ç­–ç•¥ã€‚</p>
<p>å¦‚æœæƒ³è®© SKlearn ä½¿ç”¨ <code>one-versus-one</code> æˆ– <code>one-versus-all</code>ï¼Œå¯ä»¥ä½¿ç”¨ <code>OneVsOneCLassifier</code> æˆ– <code>OneVsRestClassifier</code>ç±»ã€‚</p>
<p>ä»¥å¼ºåˆ¶ä½¿ç”¨ OvO ç­–ç•¥ä¸ºä¾‹ï¼š</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.multiclass import OneVsOneClassifier</span><br><span class="line">ovo_clf &#x3D; OneVsOneClassifier(SGDClassifier(random_state&#x3D;42))</span><br><span class="line">ovo_clf.fit(X_train, y_train)</span><br><span class="line">ovo_clf.predict([some_digit])</span><br><span class="line"># Out:</span><br><span class="line"># array([ 5.])</span><br></pre></td></tr></table></figure>

<h3 id="KNeighborsClassifier-KNN-åˆ†ç±»å™¨"><a href="#KNeighborsClassifier-KNN-åˆ†ç±»å™¨" class="headerlink" title="KNeighborsClassifier() KNN åˆ†ç±»å™¨"></a>KNeighborsClassifier() KNN åˆ†ç±»å™¨</h3><p>Classifier implementing the k-nearest neighbors vote.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.neighbors import KNeighborsClassifier</span><br><span class="line">knn_clf &#x3D; KNeighborsClassifier(n_jobs&#x3D;-1, weights&#x3D;&#39;distance&#39;, n_neighbors&#x3D;4)</span><br><span class="line">knn_clf.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line">y_knn_pred &#x3D; knn_clf.predict(X_test)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>n_jobs : int, optional (default = 1); è¿è¡Œ neighbors search å¹¶è¡Œä½œä¸šçš„æ•°é‡ã€‚å¦‚æœä¸º<code>-1</code>ï¼Œåˆ™ä½œä¸šæ•°è®¾ç½®ä¸º CPU æ ¸å¿ƒæ•°ã€‚ä¸å½±å“<code>fit</code>æ–¹æ³•</p>
</li>
<li><p>weights : str or callable, optional (default = â€˜uniformâ€™); ç”¨äºé¢„æµ‹çš„æƒé‡å‡½æ•°ï¼Œå¯èƒ½çš„å€¼å¦‚ä¸‹</p>
<table>
<thead>
<tr>
<th>keys</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>â€˜uniformâ€™</td>
<td>uniform weights. All points in each neighborhood are weighted equally.</td>
</tr>
<tr>
<td>â€˜distanceâ€™</td>
<td>weight points by the inverse of their distance. in this case, closer neighbors of a query point will have a greater influence than neighbors which are further away.</td>
</tr>
<tr>
<td>[callable]</td>
<td>a user-defined function which accepts an array of distances, and returns an array of the same shape containing the weights.</td>
</tr>
</tbody></table>
</li>
<li><p>n_neighbors : int, optional (default = 5); ç›¸é‚»è†ˆä¿ï¼Œé»˜è®¤ä½¿ç”¨<code>kneighbors</code>æŸ¥è¯¢ã€‚</p>
</li>
</ul>
<h3 id="DummyClassifier-ä½¿ç”¨ç®€å•è§„åˆ™æ¥é¢„æµ‹çš„åˆ†ç±»å™¨"><a href="#DummyClassifier-ä½¿ç”¨ç®€å•è§„åˆ™æ¥é¢„æµ‹çš„åˆ†ç±»å™¨" class="headerlink" title="DummyClassifier() ä½¿ç”¨ç®€å•è§„åˆ™æ¥é¢„æµ‹çš„åˆ†ç±»å™¨"></a>DummyClassifier() ä½¿ç”¨ç®€å•è§„åˆ™æ¥é¢„æµ‹çš„åˆ†ç±»å™¨</h3><p>è¿™ä¸ªåˆ†ç±»å™¨ä½œä¸ºä¸€ä¸ªç®€å•çš„åŸºçº¿æ¯”è¾ƒå…¶ä»–ï¼ˆçœŸæ­£çš„ï¼‰åˆ†ç±»å™¨æ˜¯æœ‰ç”¨çš„ã€‚ä¸è¦ç”¨å®ƒæ¥è§£å†³çœŸæ­£çš„é—®é¢˜ã€‚</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># çº¯éšæœºåˆ†ç±»å™¨</span><br><span class="line">from sklearn.dummy import DummyClassifier</span><br><span class="line">dmy_clf &#x3D; DummyClassifier()</span><br><span class="line">y_probas_dmy &#x3D; cross_val_predict(dmy_clf, X_train, y_train_5, cv&#x3D;3, method&#x3D;&quot;predict_proba&quot;)</span><br><span class="line">y_scores_dmy &#x3D; y_probas_dmy[:, 1]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>strategy : str, default=â€stratifiedâ€; ç”¨æ¥äº§ç”Ÿé¢„æµ‹çš„ç­–ç•¥ã€‚åœ¨ 0.17 ç‰ˆæœ¬ä¸­ï¼Œç°åœ¨æ”¯æŒäº‹å…ˆä½¿ç”¨å‚æ•°çš„å…ˆéªŒæ‹Ÿåˆç­–ç•¥ã€‚</p>
<table>
<thead>
<tr>
<th>keys</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>â€œstratifiedâ€</td>
<td>generates predictions by respecting the training setâ€™s class distribution.</td>
</tr>
<tr>
<td>â€œmost_frequentâ€</td>
<td>always predicts the most frequent label in the training set.</td>
</tr>
<tr>
<td>â€œpriorâ€</td>
<td>always predicts the class that maximizes the class prior (like â€œmost_frequentâ€) and predict_proba returns the class prior.</td>
</tr>
<tr>
<td>â€œuniformâ€</td>
<td>generates predictions uniformly at random.</td>
</tr>
<tr>
<td>â€œconstantâ€</td>
<td>always predicts a constant label that is provided by the user. This is useful for metrics that evaluate a non-majority class</td>
</tr>
</tbody></table>
</li>
<li><p>random_state : int, RandomState instance or None, optional, default=None</p>
</li>
<li><p>constant : int or str or array of shape = [n_outputs]; ä½œä¸º<code>constant</code>ç­–ç•¥çš„æ˜¾å¼å¸¸é‡ï¼Œè¯¥å‚æ•°ä»…åœ¨<code>constant</code>ç­–ç•¥ä¸­æœ‰ç”¨ã€‚</p>
<table>
<thead>
<tr>
<th>Methods</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>fit(X, y[, sample_weight])</td>
<td>Fit the random classifier.</td>
</tr>
<tr>
<td>get_params([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr>
<td>predict(X)</td>
<td>Perform classification on test vectors X.</td>
</tr>
<tr>
<td>predict_log_proba(X)</td>
<td>Return log probability estimates for the test vectors X.</td>
</tr>
<tr>
<td>predict_proba(X)</td>
<td>Return probability estimates for the test vectors X.</td>
</tr>
<tr>
<td>score(X, y[, sample_weight])</td>
<td>Returns the mean accuracy on the given test data and labels.</td>
</tr>
<tr>
<td>set_params(**params)</td>
<td>Set the parameters of this estimator.</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="accuracy-score-ç²¾åº¦åˆ†ç±»è¯„åˆ†"><a href="#accuracy-score-ç²¾åº¦åˆ†ç±»è¯„åˆ†" class="headerlink" title="accuracy_score() ç²¾åº¦åˆ†ç±»è¯„åˆ†"></a>accuracy_score() ç²¾åº¦åˆ†ç±»è¯„åˆ†</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.metrics import accuracy_score</span><br><span class="line">accuracy_score(y_test, y_knn_pred)</span><br></pre></td></tr></table></figure>

<h6 id="å‚æ•°-5"><a href="#å‚æ•°-5" class="headerlink" title="å‚æ•°"></a>å‚æ•°</h6><ul>
<li>y_true : 1d array-like, or label indicator array / sparse matrix</li>
<li>y_pred : 1d array-like, or label indicator array / sparse matrix</li>
<li>normalize : bool, optional (default=True); å¦‚æœä¸º Falseï¼Œåˆ™è¿”å›æ­£ç¡®åˆ†ç±»çš„æ ·æœ¬æ•°ã€‚å¦åˆ™ï¼Œè¿”å›æ­£ç¡®åˆ†ç±»æ ·æœ¬çš„ä¸€å°éƒ¨åˆ†ã€‚</li>
<li>sample_weight : array-like of shape = [n_samples], optional; æ ·æœ¬æƒé‡</li>
</ul>
<h6 id="è¿”å›å€¼-4"><a href="#è¿”å›å€¼-4" class="headerlink" title="è¿”å›å€¼"></a>è¿”å›å€¼</h6><ul>
<li>score : floatï¼› å¦‚æœ normalize == Trueï¼Œåˆ™è¿”å›æ­£ç¡®åˆ†ç±»çš„æ ·æœ¬ï¼ˆfloatï¼‰ï¼Œå¦åˆ™è¿”å›æ­£ç¡®åˆ†ç±»çš„æ ·æœ¬æ•°é‡ï¼ˆintï¼‰ã€‚</li>
</ul>
<h3 id="SGDRegressor-SGD-å›å½’"><a href="#SGDRegressor-SGD-å›å½’" class="headerlink" title="SGDRegressor() SGD å›å½’"></a>SGDRegressor() SGD å›å½’</h3><p>çº¿æ€§æ¨¡å‹é€šè¿‡ä½¿ SGD æ­£åˆ™åŒ–çš„ç»éªŒæŸå¤±æœ€å°åŒ–æ¥æ‹Ÿåˆï¼›SGD ä»£è¡¨éšæœºæ¢¯åº¦ä¸‹é™</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.linear_model import SGDRegressor</span><br><span class="line">sgd_reg &#x3D; SGDRegressor(n_iter&#x3D;50, penalty&#x3D;None, eta0&#x3D;0.1, random_state&#x3D;42)</span><br><span class="line">sgd_reg.fit(X, y.ravel())</span><br></pre></td></tr></table></figure>

<h6 id="å‚æ•°-6"><a href="#å‚æ•°-6" class="headerlink" title="å‚æ•°"></a>å‚æ•°</h6><ul>
<li>n_iter : int, optionalï¼›è®­ç»ƒæ•°æ®çš„é€šè¿‡æ¬¡æ•°ï¼ˆåˆç§° epochsï¼‰ã€‚é»˜è®¤ä¸º Noneã€‚å·²å¼ƒç”¨ï¼Œå°†åœ¨ 0.21 ä¸­åˆ é™¤ã€‚</li>
<li>max_iter : int, optionalï¼›è®­ç»ƒæ•°æ®çš„æœ€å¤§é€šè¿‡æ¬¡æ•°ï¼ˆä¹Ÿç§°ä¸º epochsï¼‰ã€‚æ›¿æ¢<code>n_iter</code>å‚æ•°ã€‚</li>
<li>penalty : str, â€˜noneâ€™, â€˜l2â€™, â€˜l1â€™, or â€˜elasticnetâ€™ï¼›penalty æœ¯è¯­ä¹Ÿå«æ­£åˆ™åŒ–ï¼Œé»˜è®¤ä¸º<code>l1</code>ã€‚</li>
<li>eta0 : double, optionalï¼›å§‹å­¦ä¹ ç‡ï¼Œé»˜è®¤ä¸º 0.01ã€‚</li>
<li>warm_start : bool, optionalï¼›è®¾ç½®ä¸º True æ—¶ï¼Œé‡æ–°ä½¿ç”¨å…ˆå‰è°ƒç”¨<code>fit()</code>çš„è§£å†³æ–¹æ¡ˆä»¥åˆå§‹åŒ–ï¼Œå¦åˆ™ï¼Œåªéœ€æ“¦é™¤ä»¥å‰çš„è§£å†³æ–¹æ¡ˆã€‚</li>
<li>random_state : int, RandomState instance or None, optional (default=None)ï¼›éšæœºç§å­ã€‚</li>
</ul>
<h6 id="å±æ€§"><a href="#å±æ€§" class="headerlink" title="å±æ€§"></a>å±æ€§</h6><table>
<thead>
<tr>
<th>keys</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>coef_ : array, shape (n_features,)</td>
<td>Weights assigned to the features.</td>
</tr>
<tr>
<td>intercept_ : array, shape (1,)</td>
<td>The intercept term.</td>
</tr>
<tr>
<td>average<em>coef</em> : array, shape (n_features,)</td>
<td>Averaged weights assigned to the features.</td>
</tr>
<tr>
<td>average<em>intercept</em> : array, shape (1,)</td>
<td>The averaged intercept term.</td>
</tr>
<tr>
<td>n<em>iter</em> : int</td>
<td>The actual number of iterations to reach the stopping criterion.</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>Methods</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>densify()</td>
<td>Convert coefficient matrix to dense array format.</td>
</tr>
<tr>
<td>fit(X, y[, coef_init, intercept_init, â€¦])</td>
<td>Fit linear model with Stochastic Gradient Descent.</td>
</tr>
<tr>
<td>get_params([deep])</td>
<td>Get parameters for this estimator.</td>
</tr>
<tr>
<td>partial_fit(X, y[, sample_weight])</td>
<td>Fit linear model with Stochastic Gradient Descent.</td>
</tr>
<tr>
<td>predict(X)</td>
<td>Predict using the linear model</td>
</tr>
<tr>
<td>score(X, y[, sample_weight])</td>
<td>Returns the coefficient of determination R^2 of the prediction.</td>
</tr>
<tr>
<td>set_params(*args, **kwargs)</td>
<td></td>
</tr>
<tr>
<td>sparsify()</td>
<td>Convert coefficient matrix to sparse format.</td>
</tr>
</tbody></table>
<h3 id="PolynomialFeatures-ç”Ÿæˆå¤šé¡¹å¼å’Œäº¤äº’ç‰¹å¾"><a href="#PolynomialFeatures-ç”Ÿæˆå¤šé¡¹å¼å’Œäº¤äº’ç‰¹å¾" class="headerlink" title="PolynomialFeatures() ç”Ÿæˆå¤šé¡¹å¼å’Œäº¤äº’ç‰¹å¾"></a>PolynomialFeatures() ç”Ÿæˆå¤šé¡¹å¼å’Œäº¤äº’ç‰¹å¾</h3><p>ç”Ÿæˆä¸€ä¸ªæ–°çš„ç‰¹å¾çŸ©é˜µï¼Œè¯¥ç‰¹å¾çŸ©é˜µç”±åº¦æ•°å°äºæˆ–ç­‰äºæŒ‡å®šåº¦çš„ç‰¹å¾çš„æ‰€æœ‰å¤šé¡¹å¼ç»„åˆç»„æˆã€‚ ä¾‹å¦‚ï¼Œå¦‚æœè¾“å…¥æ ·æœ¬æ˜¯äºŒç»´çš„å¹¶ä¸”å½¢å¼ä¸º[aï¼Œb]ï¼Œåˆ™ 2 æ¬¡å¤šé¡¹å¼ç‰¹å¾æ˜¯[1ï¼Œaï¼Œbï¼Œa ^ 2ï¼Œabï¼Œb ^ 2]ã€‚</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.preprocessing import PolynomialFeatures</span><br><span class="line">poly_features &#x3D; PolynomialFeatures(degree&#x3D;2, include_bias&#x3D;False)</span><br><span class="line">X_poly &#x3D; poly_features.fit_transform(X)</span><br><span class="line">X[0]</span><br><span class="line"># array([-0.75275929])</span><br></pre></td></tr></table></figure>

<h6 id="å‚æ•°-7"><a href="#å‚æ•°-7" class="headerlink" title="å‚æ•°"></a>å‚æ•°</h6><ul>
<li>degree : integerï¼›å¤šé¡¹å¼ç‰¹å¾åº¦æ•°ï¼Œé»˜è®¤å€¼ä¸º 2ã€‚</li>
<li>include_bias : booleanï¼›å¦‚æœä¸º Trueï¼ˆé»˜è®¤å€¼ï¼‰ï¼Œåˆ™åŒ…å«ä¸€ä¸ªåç½®åˆ—ï¼Œå³æ‰€æœ‰å¤šé¡¹å¼å¹‚ä¸º 0ï¼ˆä½œä¸ºçº¿æ€§æ¨¡å‹çš„æˆªè·é¡¹ï¼‰ã€‚</li>
<li>interaction_only : boolean, default = Falseï¼›å¦‚æœä¸º Trueï¼Œåˆ™åªäº§ç”Ÿç›¸äº’ç‰¹å¾ã€‚</li>
</ul>
<h6 id="å±æ€§-1"><a href="#å±æ€§-1" class="headerlink" title="å±æ€§"></a>å±æ€§</h6><table>
<thead>
<tr>
<th>keys</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>powers_ : array, shape (n_output_features, n_input_features)</td>
<td>powers_[i, j] is the exponent of the jth input in the ith output.</td>
</tr>
<tr>
<td>n<em>input_features</em> : int</td>
<td>The total number of input features.</td>
</tr>
<tr>
<td>n<em>output_features</em> : int</td>
<td>The total number of polynomial output features. The number of output features is computed by iterating over all suitably sized combinations of input features.</td>
</tr>
</tbody></table>
<h3 id="Ridge-å…·æœ‰-L2-æ­£åˆ™åŒ–çš„çº¿æ€§æœ€å°äºŒä¹˜"><a href="#Ridge-å…·æœ‰-L2-æ­£åˆ™åŒ–çš„çº¿æ€§æœ€å°äºŒä¹˜" class="headerlink" title="Ridge() å…·æœ‰ L2 æ­£åˆ™åŒ–çš„çº¿æ€§æœ€å°äºŒä¹˜"></a>Ridge() å…·æœ‰ L2 æ­£åˆ™åŒ–çš„çº¿æ€§æœ€å°äºŒä¹˜</h3><p>è¿™ä¸ªæ¨¡å‹è§£å†³ä¸€ä¸ªä½¿ç”¨æœ€å°äºŒä¹˜<code>loss</code>å‡½æ•°ï¼Œä½¿ç”¨<code>l2-norm</code>æ­£åˆ™å‡½æ•°çš„å›å½’æ¨¡å‹ã€‚è¿™ä¸ªä¼°è®¡å™¨å†…ç½®äº†å¯¹å¤šå˜é‡å›å½’çš„æ”¯æŒï¼ˆä¾‹å¦‚ï¼šy æ˜¯ä¸€ä¸ªå½¢çŠ¶ä¸º[n_samples, n_targets]äºŒç»´æ•°ç»„ï¼‰ã€‚</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.linear_model import Ridge</span><br><span class="line">ridge_reg &#x3D; Ridge(alpha&#x3D;1, solver&#x3D;&quot;cholesky&quot;, random_state&#x3D;42)</span><br><span class="line">ridge_reg.fit(X, y)</span><br><span class="line">ridge_reg.predict([[1.5]])</span><br><span class="line"># array([[ 1.55071465]])</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ridge_reg &#x3D; Ridge(alpha&#x3D;1, solver&#x3D;&quot;sag&quot;, random_state&#x3D;42)</span><br><span class="line">ridge_reg.fit(X, y)</span><br><span class="line">ridge_reg.predict([[1.5]])</span><br><span class="line"># array([[ 1.5507201]])</span><br></pre></td></tr></table></figure>

<h6 id="å‚æ•°-8"><a href="#å‚æ•°-8" class="headerlink" title="å‚æ•°"></a>å‚æ•°</h6><ul>
<li>alpha : {float, array-like}, shape (n_targets)ï¼›æ­£åˆ™åŒ–å¼ºåº¦ï¼Œå¿…é¡»ä¸ºæ­£çš„ float ç±»å‹ã€‚</li>
<li>random_state : int, RandomState instance or None, optional, default None</li>
<li>fit_intercept : booleanï¼›æ˜¯å¦è®¡ç®—æ­¤æ¨¡å‹çš„æˆªè·ã€‚å¦‚æœè®¾ç½®ä¸º falseï¼Œåˆ™è®¡ç®—ä¸­å°†ä¸ä½¿ç”¨æˆªè·ï¼ˆä¾‹å¦‚ï¼Œæ•°æ®é¢„æœŸå·²å±…ä¸­ï¼‰ã€‚</li>
<li>solver : {â€˜autoâ€™, â€˜svdâ€™, â€˜choleskyâ€™, â€˜lsqrâ€™, â€˜sparse_cgâ€™, â€˜sagâ€™, â€˜sagaâ€™}ï¼›ç”¨äºè®¡ç®—ä¾‹ç¨‹çš„æ±‚è§£å™¨ã€‚è¯¦ç»†ä»‹ç»ï¼š<table>
<thead>
<tr>
<th>keys</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>â€˜autoâ€™</td>
<td>chooses the solver automatically based on the type of data.</td>
</tr>
<tr>
<td>â€˜svdâ€™</td>
<td>uses a Singular Value Decomposition of X to compute the Ridge coefficients. More stable for singular matrices than â€˜choleskyâ€™.</td>
</tr>
<tr>
<td>â€˜choleskyâ€™</td>
<td>uses the standard scipy.linalg.solve function to obtain a closed-form solution.</td>
</tr>
<tr>
<td>â€˜sparse_cgâ€™</td>
<td>uses the conjugate gradient solver as found in scipy.sparse.linalg.cg. As an iterative algorithm, this solver is more appropriate than â€˜choleskyâ€™ for large-scale data (possibility to set tol and max_iter).</td>
</tr>
<tr>
<td>â€˜lsqrâ€™</td>
<td>uses the dedicated regularized least-squares routine scipy.sparse.linalg.lsqr. It is the fastest but may not be available in old scipy versions. It also uses an iterative procedure.</td>
</tr>
<tr>
<td>â€˜sagâ€™</td>
<td>uses a Stochastic Average Gradient descent, and â€˜sagaâ€™ uses its improved, unbiased version named SAGA. Both methods also use an iterative procedure, and are often faster than other solvers when both n_samples and n_features are large. Note that â€˜sagâ€™ and â€˜sagaâ€™ fast convergence is only guaranteed on features with approximately the same scale. You can preprocess the data with a scaler from sklearn.preprocessing.</td>
</tr>
</tbody></table>
</li>
</ul>
<h6 id="å±æ€§-2"><a href="#å±æ€§-2" class="headerlink" title="å±æ€§"></a>å±æ€§</h6><table>
<thead>
<tr>
<th>keys</th>
<th>description</th>
</tr>
</thead>
<tbody><tr>
<td>coef_ : array, shape (n_features,) or (n_targets, n_features)</td>
<td>Weight vector(s).</td>
</tr>
<tr>
<td>intercept_ : float array, shape = (n_targets,)</td>
<td>Independent term in decision function. Set to 0.0 if fit_intercept = False.</td>
</tr>
<tr>
<td>n<em>iter</em> : array or None, shape (n_targets,)</td>
<td>Actual number of iterations for each target. Available only for sag and lsqr solvers. Other solvers will return None.New in version 0.17.</td>
</tr>
</tbody></table>
<h3 id="Lasso-ç”¨-L1-é¢„å…ˆæ­£åˆ™åŒ–çš„çº¿æ€§æ¨¡å‹"><a href="#Lasso-ç”¨-L1-é¢„å…ˆæ­£åˆ™åŒ–çš„çº¿æ€§æ¨¡å‹" class="headerlink" title="Lasso()   ç”¨ L1 é¢„å…ˆæ­£åˆ™åŒ–çš„çº¿æ€§æ¨¡å‹"></a>Lasso()   ç”¨ L1 é¢„å…ˆæ­£åˆ™åŒ–çš„çº¿æ€§æ¨¡å‹</h3><p>Lasso ä¼˜åŒ–ç›®æ ‡<br><code>(1 / (2 * n_samples)) * ||y - Xw||^2_2 + alpha * ||w||_1</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.linear_model import Lasso</span><br><span class="line">lasso_reg &#x3D; Lasso(alpha&#x3D;0.1)</span><br><span class="line">lasso_reg.fit(X, y)</span><br><span class="line">lasso_reg.predict([[1.5]])</span><br></pre></td></tr></table></figure>

<ul>
<li>alpha : float, optionalï¼›ä¹˜ä»¥ L1 é¡¹çš„å¸¸æ•°ã€‚</li>
<li>fit_intercept : booleanï¼›æ˜¯å¦è®¡ç®—è¿™ä¸ªæ¨¡å‹çš„æˆªè·ï¼Œå¦‚æœè®¾ç½®ä¸º Falseï¼Œåˆ™ä¸ä¼šè®¡ç®—æˆªè·ï¼ˆä¾‹å¦‚æ•°æ®å·²å±…ä¸­ï¼‰ã€‚</li>
<li>random_state : int, RandomState instance or None, optional, default None</li>
</ul>
<h3 id="ElasticNet-ç»“åˆ-L1ã€L2-ä½œä¸ºé¢„å…ˆæ­£åˆ™åŒ–çš„çº¿æ€§å›å½’"><a href="#ElasticNet-ç»“åˆ-L1ã€L2-ä½œä¸ºé¢„å…ˆæ­£åˆ™åŒ–çš„çº¿æ€§å›å½’" class="headerlink" title="ElasticNet()   ç»“åˆ L1ã€L2 ä½œä¸ºé¢„å…ˆæ­£åˆ™åŒ–çš„çº¿æ€§å›å½’"></a>ElasticNet()   ç»“åˆ L1ã€L2 ä½œä¸ºé¢„å…ˆæ­£åˆ™åŒ–çš„çº¿æ€§å›å½’</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.linear_model import ElasticNet</span><br><span class="line">elastic_net &#x3D; ElasticNet(alpha&#x3D;0.1, l1_ratio&#x3D;0.5, random_state&#x3D;42)</span><br><span class="line">elastic_net.fit(X, y)</span><br><span class="line">elastic_net.predict([[1.5]])</span><br></pre></td></tr></table></figure>

<ul>
<li>alpha : float, optionalï¼›ä¹˜ä»¥æƒ©ç½šé¡¹çš„å¸¸æ•°ã€‚</li>
<li>l1_ratio : floatï¼›ElasticNet æ··åˆå‚æ•°ã€‚</li>
<li>random_state : int, RandomState instance or None, optional, default None</li>
</ul>
<h3 id="clone-ç”¨ç›¸åŒçš„å‚æ•°æ„é€ ä¸€ä¸ªæ–°çš„ä¼°è®¡å™¨ã€‚"><a href="#clone-ç”¨ç›¸åŒçš„å‚æ•°æ„é€ ä¸€ä¸ªæ–°çš„ä¼°è®¡å™¨ã€‚" class="headerlink" title="clone()   ç”¨ç›¸åŒçš„å‚æ•°æ„é€ ä¸€ä¸ªæ–°çš„ä¼°è®¡å™¨ã€‚"></a>clone()   ç”¨ç›¸åŒçš„å‚æ•°æ„é€ ä¸€ä¸ªæ–°çš„ä¼°è®¡å™¨ã€‚</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.base import clone</span><br><span class="line">sgd_reg &#x3D; SGDRegressor(n_iter&#x3D;1, warm_start&#x3D;True, penalty&#x3D;None,</span><br><span class="line">                       learning_rate&#x3D;&quot;constant&quot;, eta0&#x3D;0.0005, random_state&#x3D;42)</span><br><span class="line"></span><br><span class="line">minimum_val_error &#x3D; float(&quot;inf&quot;)</span><br><span class="line">best_epoch &#x3D; None</span><br><span class="line">best_model &#x3D; None</span><br><span class="line">for epoch in range(1000):</span><br><span class="line">    sgd_reg.fit(X_train_poly_scaled, y_train)  # continues where it left off</span><br><span class="line">    y_val_predict &#x3D; sgd_reg.predict(X_val_poly_scaled)</span><br><span class="line">    val_error &#x3D; mean_squared_error(y_val_predict, y_val)</span><br><span class="line">    if val_error &lt; minimum_val_error:</span><br><span class="line">        minimum_val_error &#x3D; val_error</span><br><span class="line">        best_epoch &#x3D; epoch</span><br><span class="line">        best_model &#x3D; clone(sgd_reg)</span><br></pre></td></tr></table></figure>

<ul>
<li>estimator : estimator object, or list, tuple or set of objectsï¼›è¦å¤åˆ¶çš„ä¼°è®¡å™¨å¯¹è±¡</li>
</ul>
<h3 id="datasets-ä¸‹è½½å¸¸ç”¨çš„æ•°æ®é›†"><a href="#datasets-ä¸‹è½½å¸¸ç”¨çš„æ•°æ®é›†" class="headerlink" title="datasets()   ä¸‹è½½å¸¸ç”¨çš„æ•°æ®é›†"></a>datasets()   ä¸‹è½½å¸¸ç”¨çš„æ•°æ®é›†</h3><p><a href="http://scikit-learn.org/stable/datasets/index.html" target="_blank" rel="external nofollow noopener noreferrer">details</a></p>
<p>ä¸‹è½½é¸¢å°¾èŠ±æ•°æ®é›†</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from sklearn import datasets</span><br><span class="line">iris &#x3D; datasets.load_iris()</span><br></pre></td></tr></table></figure>

<h3 id="LogisticRegression-Logistic-å›å½’"><a href="#LogisticRegression-Logistic-å›å½’" class="headerlink" title="LogisticRegression() Logistic å›å½’"></a>LogisticRegression() Logistic å›å½’</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from sklearn.linear_model import LogisticRegression</span><br><span class="line">log_reg &#x3D; LogisticRegression(random_state&#x3D;42)</span><br><span class="line">log_reg.fit(X, y)</span><br></pre></td></tr></table></figure>

<ul>
<li>penalty : str, â€˜l1â€™ or â€˜l2â€™, default: â€˜l2â€™</li>
<li>dual : bool, default: Falseï¼›Dual æˆ–åŸå§‹å…¬å¼ï¼ŒDual å…¬å¼åªé€‚ç”¨äºä½¿ç”¨ L2 æƒ©ç½šçš„çº¿æ€§æ±‚è§£å™¨ï¼Œå½“ n_samples &gt; n_features ä¼˜å…ˆä½¿ç”¨ dual=Falseã€‚</li>
<li>tol : float, default: 1e-4ï¼›å¯¹åœæ­¢çš„å®¹å¿æ ‡å‡†ã€‚</li>
<li>C : float, default: 1.0ï¼› æ­£åˆ™åŒ–å¼ºåº¦çš„åè½¬ï¼Œå¿…é¡»æ˜¯ä¸€ä¸ªæ­£å€¼ï¼Œå°±åƒåœ¨æ”¯æŒå‘é‡æœºä¸­ä¸€æ ·ï¼Œè¾ƒå°çš„å€¼æŒ‡å®šæ›´å¼ºçš„æ­£åˆ™åŒ–ã€‚</li>
</ul>
    </div>
  </div>
  
    <div class="copy-right">
      <div class="markdown-body">
        <blockquote>
        
        
          æœ¬æ–‡ä½œè€… : HeoLis <br>
        
        åŸæ–‡é“¾æ¥ : <a href="">https://ishero.net/SKlearn%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html</a><br>
        ç‰ˆæƒå£°æ˜ : æœ¬åšå®¢æ‰€æœ‰æ–‡ç« é™¤ç‰¹åˆ«å£°æ˜å¤–ï¼Œå‡é‡‡ç”¨ <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="external nofollow noopener noreferrer">CC BY-NC-SA 4.0</a> è®¸å¯åè®®ã€‚è½¬è½½è¯·æ³¨æ˜å‡ºå¤„ï¼
        </blockquote>
      </div>
    </div>
  
  
  
    <div class="social-share" style="margin-top: -2rem" data-wechat-qrcode-title="<p>å¾®ä¿¡æ‰«ä¸€æ‰«</p>" data-wechat-qrcode-helper="<p>å¾®ä¿¡å³ä¸Šè§’, æ‰«ä¸€æ‰«åˆ†äº«</p>" data-sites="qzone, qq, weibo, wechat, douban, google, facebook, twitter">
  <span style="color: #6b7487; font-size: 1.4rem;">åˆ†äº«åˆ°: </span>
</div>
<script src="https://cdn.bootcss.com/social-share.js/1.0.16/js/social-share.min.js" async></script>
  

  
    <div id="reward">
  
    <p id="reward-meta">å­¦ä¹ ã€è®°å½•ã€åˆ†äº«ã€è·å¾—</p>
  
  <button id="reward-btn">
    
    <span>æ‰“èµ</span>
  </button>
  <div id="reward-qrcode">
    
      <div class="reward-qrcode--container">
        <img class="qrcode-img" src="/images/donate-qr.png" alt="å¾®ä¿¡æ‰«ä¸€æ‰«, å‘æˆ‘æŠ•é£Ÿ">
        <p class="qrcode-meta">å¾®ä¿¡æ‰«ä¸€æ‰«, å‘æˆ‘æŠ•é£Ÿ</p>
      </div>
    
  </div>

</div>

<script>
  (() => {
    let button = document.querySelector('#reward-btn'),
      qrcode = document.querySelector('#reward-qrcode'),
      display = false;
    
    button.addEventListener('click', () => {
      qrcode.style.display = display ? 'none' : 'block'
      display = !display
    }, false)
  })()
</script>
  

  <div class="article-footer">
    <div class="article-meta pull-left">
      <span>
        
          <i class="iconfont icon-06tags"></i>æ ‡ç­¾: 
          
          <span class="span--tag">
            <a href="/tags/sklearn/">
              #sklearn
            </a>
          </span>
          
        
      </span>
    </div>
    <div class="article-meta pull-right">
    </div>
  </div>
</div>


  <aside id="sidebar">
    <p id="sidebar-header"></p>
    <ol id="sidebar-toc"></ol>
  </aside>
  <script async>setTimeout(generateToc, 10);</script>



  <nav class="post-navigation">
    
      <div class="nav-pre">
        <i class="iconfont icon-prev"></i>
        ä¸Šä¸€ç¯‡:
        <a href="/Pandas%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html" target="_self">Pandaså­¦ä¹ ç¬”è®°</a>
      </div>
    
    
      <div class="nav-next">
        ä¸‹ä¸€ç¯‡:
        <a href="/%E6%95%B0%E6%8D%AE%E9%A2%84%E5%A4%84%E7%90%86%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9CI.html" target="_self">æ•°æ®é¢„å¤„ç†å¸¸ç”¨æ“ä½œI</a>
        <i class="iconfont icon-next"></i>
      </div>
    
  </nav>

   

  
    <script defer>
const valineAPI = (() => {
  try {
    AV.init("Epge4Qisj9i3E08wl1q1cSWB-gzGzoHsz", "ClV5c29GDRy9RkLPqrac09OT");
  } catch(error) {}
  const isExist = (identity) => {
    identity = identity || getRealPath();
    let query = new AV.Query('Timer');
    return new Promise((resolve, reject) => {
      query.equalTo("identity", identity);
      query.find().then(results => {
        resolve(results.length > 0);
      }, error => reject(error));
    })
  }

  const _get = (identity) => {
    let query = null;
    if(identity && identity instanceof Array){
      let querys = [];
      for(let i = 0; i < identity.length; ++i) {
        querys[i] = new AV.Query('Timer');
        querys[i].equalTo('identity', identity[i]);
      }
      query = AV.Query.or.apply(null ,querys);
    } else {
      identity = identity || getRealPath();
      query = new AV.Query("Timer");
      query.equalTo("identity", identity);
    }

    return new Promise((resolve, reject) => {
      query.find()
      .then(results => resolve(results))
      .catch(error => reject(error))
    })
  }

  const create = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let Todo = AV.Object.extend('Timer');
      let todo = new Todo();
      todo.set("times", 1);
      todo.set("identity", identity);
      todo.save().then(res => resolve(true), error => reject(error));
    })
  }

  const update = (identity) => {
    identity = identity || getRealPath();
    return new Promise((resolve, reject) => {
      let query = new AV.Query('Timer');
      query.equalTo("identity", identity);
      query.find().then(todos => {
        todos.forEach(todo => {
          todo.set("times", todo.attributes.times + 1);
        });
        return AV.Object.saveAll(todos);
      }).then(todos => resolve(true), error => reject(error));
    })
  }

  return {
    isExist,
    _get,
    update,
    create
  }
})()

const calcAndWriteTimes = () => {
  let isPost = true;

  let timerAllDOM = document.querySelectorAll(".article-timer");

  if(isPost) {
    let identity = timerAllDOM[0].getAttribute("data-identity");
    valineAPI.isExist(identity)
    .then(exist => {
      if(exist) {
        return valineAPI.update(identity);
      }
      return new Promise(resolve => resolve(true));
    })
    .then( succuess => valineAPI._get(identity))
    .then( result => timerAllDOM[0].innerText = result[0].attributes.times)
    .catch(error => console.log(error.message))
    return ;
  }

  let timerDOMCache = {};

  for(let timerDOM of timerAllDOM) {
    let identity = timerDOM.getAttribute("data-identity");
    if(timerDOMCache.hasOwnProperty(identity)){
      timerDOMCache[identity].dom.push(timerDOM);
    }else{
      timerDOMCache[identity] = {
        dom: [timerDOM],
        times: undefined
      };
    }
  }

  let identities = Object.keys(timerDOMCache);
  valineAPI._get(identities).then(results => {
    for(let result of results) {
      let {identity, times} = result.attributes;
      timerDOMCache[identity].times = times;
      timerDOMCache[identity].dom.map(item => item.innerText = times);
    }
    for(let identity of identities) {
      if(timerDOMCache[identity].times){
        continue;
      }
      timerDOMCache[identity].dom.map(item => item.innerText = 1);
      valineAPI.create(identity);
    }
  }).catch(error => console.log(error.message))
}

if(true){
  calcAndWriteTimes();
}
</script>
   

</div>



      <footer>
  <p class="site-info">
    åšå®¢å·²èŒèŒå“’è¿è¡Œ<span id="time-to-now"></span><span class="my-face">(â—'â—¡'â—)ï¾‰â™¥</span>
    <br>
    Theme - <a href="https://github.com/dongyuanxin/theme-bmw" target="_blank" rel="external nofollow noopener noreferrer">BMW</a> | Made With ğŸ’— | Powered by <a href="https://godbmw.com/" target="_blank" rel="external nofollow noopener noreferrer">GodBMW</a>
    <br>
    ICPè¯:<a href="http://www.beian.miit.gov.cn" target="_blank" rel="external nofollow noopener noreferrer">ç²¤ICPå¤‡19011977å·-1</a> 
  </p>
</footer>



<script>
const timeToNowDOM = document.querySelector("#time-to-now");
const startTimestamp = new Date(2017, 8, 20).getTime();

const updateTimeStr = () => {
  let offset = parseInt(
      (new Date().getTime() - startTimestamp) / 1000,
      10
    ),
    day = Math.floor(offset / 86400),
    hour = Math.floor((offset % 86400) / 3600),
    minute = Math.floor(((offset % 86400) % 3600) / 60),
    second = Math.floor(((offset % 86400) % 3600) % 60);
  timeToNowDOM.innerHTML =
    day + "å¤©" + hour + "å°æ—¶" + minute + "åˆ†é’Ÿ" + second + "ç§’";
  setTimeout(updateTimeStr, 500);
}

setTimeout(updateTimeStr, 500);
</script>


      <div class="back-to-top hidden">
  <span>
    <i class="iconfont icon-60"></i><span></span>%
  </span>
</div>

<script>
const updateIconToTop = percent => {
  let dom = document.querySelector(".back-to-top span span");
  dom.innerText = percent;
  if(percent < 1) {
    document.querySelector(".back-to-top").className = "back-to-top hidden";
  } else {
    document.querySelector(".back-to-top").className = "back-to-top";
  }
}

const handleScoll = () => {
  let isRunning = false;
  return () => {
    if (isRunning) return;
    isRunning = true;
    window.requestAnimationFrame(timestamp => {
      let scrollTop =
          document.documentElement.scrollTop || document.body.scrollTop,
        scrollHeight =
          document.documentElement.scrollHeight ||
          document.body.scrollHeight,
        clientHeight =
          document.documentElement.clientHeight ||
          document.body.clientHeight;
      isRunning = false;
      if (scrollTop <= 1) {
        updateIconToTop(0);
        return;
      }
      if (scrollTop + clientHeight >= scrollHeight) {
        updateIconToTop(100);
      } else {
        updateIconToTop(parseInt(
          100 * scrollTop / (scrollHeight - clientHeight),
          10
        ));
      }
    });
  };
}

const backToTop = () => {
  let scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop,
    delay = 10,
    time = 200;
  if (scrollTop <= 20) {
    document.documentElement.scrollTop = 0;
    document.body.scrollTop = 0;
    return;
  }
  let step = Math.ceil(scrollTop * delay / time);
  let timer = setInterval(() => {
    scrollTop =
      document.documentElement.scrollTop || document.body.scrollTop;
    if (scrollTop - step <= 0) {
      document.documentElement.scrollTop = 0;
      document.body.scrollTop = 0;
      clearInterval(timer);
    } else {
      document.documentElement.scrollTop = scrollTop - step;
      document.body.scrollTop = scrollTop - step;
    }
  }, delay);
}

document.addEventListener("scroll", handleScoll(), false);

document.querySelector(".back-to-top").addEventListener("click", backToTop, false);

</script>

    </div>

    
      <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
<script>
  (() => {
    const mathjaxConfig = {
      showProcessingMessages: false, //å…³é—­jsåŠ è½½è¿‡ç¨‹ä¿¡æ¯
      messageStyle: "none", //ä¸æ˜¾ç¤ºä¿¡æ¯
      jax: ["input/TeX", "output/HTML-CSS"],
      tex2jax: {
        inlineMath: [["$", "$"], ["\\(", "\\)"]], //è¡Œå†…å…¬å¼é€‰æ‹©ç¬¦
        displayMath: [["$$", "$$"], ["\\[", "\\]"]], //æ®µå†…å…¬å¼é€‰æ‹©ç¬¦
        skipTags: ["script", "noscript", "style", "textarea", "pre", "code", "a"] //é¿å¼€æŸäº›æ ‡ç­¾
      },
      "HTML-CSS": {
        availableFonts: ["STIX", "TeX"], //å¯é€‰å­—ä½“
        showMathMenu: false //å…³é—­å³å‡»èœå•æ˜¾ç¤º
      }
    }

    let mathjaxInterval = setInterval(() => {
      if(!window.MathJax){
        return;
      }
      window.MathJax.Hub.Config(mathjaxConfig)
      window.MathJax.Hub.Queue(["Typeset", MathJax.Hub, document.getElementById('app')])

      clearInterval(mathjaxInterval)
    }, 10)    
  })()
</script>
    

    <script src="https://cdn.bootcss.com/fancybox/3.5.2/jquery.fancybox.min.js" async></script>
<script async>
  let fancyTimer = setInterval(function(){
    if(!window.$){
      return;
    }
    $(document).ready(function() {
      $(".post img").each(function () {
        if($(this).parent().get(0).tagName.toLowerCase() === "a") {
          return;
        }
        // $(this).attr("data-fancybox", "gallery"); // if you add 'data-fancybox', img will display after showed
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "gallery");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      });
      
      clearInterval(fancyTimer);
    });
  }, 10);
</script>

    
      
         
          <script src="/custom/script.js" async></script>
        
      
    
  </body>

</html>
